# TravelTracker
## Общие описание

Это систему хранения транспортных маршрутов и обработки запросов к ней. Сначала на вход подаются запросы на создание базы данных, затем — запросы к самой базе. Небольшой аналог движка для Google Maps и подобных приложения.

### Формат ввода базы данных
Запросы на создание объектов в базе данных задаются в виде списка в ключе base_requests входного JSON. Каждый запрос является словарём, содержащим ключ type — тип запроса, а также прочую дополнительную информацию о соответствующем объекте.

#### Stop: описание остановки

Пример:
```json
{
  "type": "Stop",
  "name": "Tolstopaltsevo",
  "latitude": 55.611087,
  "longitude": 37.20829,
  "road_distances": {
    "Marushkino": 3900
  }
}
```
•	name — название остановки;

•	latitude и longitude — широта и долгота;

•	road_distances — расстояния по дорогам от этой остановки до соседних. Все расстояния задаются в метрах и являются целыми положительными числами, каждое из которых не превышает 1000000 и не меньше расстояния по земной поверхности между соответствующими остановками.

Гарантируется, что каждая из остановок из road_distances определена в некотором запросе Stop.

#### Bus: описание автобуса

Пример:
```json
{
  "type": "Bus",
  "name": "750",
  "stops": [
    "Tolstopaltsevo",
    "Marushkino",
    "Rasskazovka"
  ],
  "is_roundtrip": false
}
```
Запрос на добавление автобуса с названием, заданным в ключе name. Маршрут может задаваться в одном из двух форматов:

1.	"is_roundtrip": false: автобус следует по списку остановок из stops от первой до последней и обратно.

2.	"is_roundtrip": true: кольцевой маршрут, у которого первая остановка из списка stops является конечной.

По сути описание автобуса из последнего примера эквивалентно следующему:
```json
{
  "type": "Bus",
  "name": "750",
  "stops": [
    "Tolstopaltsevo",
    "Marushkino",
    "Rasskazovka",
    "Marushkino",
    "Tolstopaltsevo"
  ],
  "is_roundtrip": true
}
```
Разница между двумя форматами лишь в том, что в первом случае последняя остановка считается конечной — но это важно лишь в части H и далее. С точки зрения механики маршрутизации выделяется лишь первая остановка, так как на ней пассажиры высаживаются из автобуса.

Гарантируется, что каждая из остановок маршрута определена в некотором запросе Stop, а сам автобус определён не более чем в одном запросе Bus.

### Секция routing_settings

Входной JSON содержит ключ routing_settings, значением которого является словарь с двумя ключами:

•	"bus_wait_time" — время ожидания автобуса на остановке (в минутах). Считайте, что когда бы человек ни пришёл на остановку и какой бы ни была эта остановка, он будет ждать любой автобус в точности указанное количество минут. Значение — целое число от 1 до 1000.

•	"bus_velocity" — скорость автобуса (в км/ч). Считайте, что скорость любого автобуса постоянна и в точности равна указанному числу. Время стоянки на остановках не учитывается, время разгона и торможения — тоже. Значение — вещественное число от 1 до 1000.

Пример 
```json
"routing_settings": {
  "bus_wait_time": 6,
  "bus_velocity": 40
}
```
Данная конфигурация задаёт время ожидания равным 6 минутам и скорость автобусов равной 40 километрам в час.

### Формат запросов к базе данных

Запросы к базе данных задаются в виде списка в ключе stat_requests входного JSON. Каждый запрос является словарём, обязательно содержащим два ключа:

•	type — тип запроса;

•	id — целое число от 0 до 2147483647.

Ответы на запросы выводятся в виде списка, каждый элемент которого в поле request_id содержит id исходного запроса.

#### Bus: информация об автобусе

Пример:
```json
{
  "route_length": 5950,
  "request_id": 1965312327,
  "curvature": 1.36124,
  "stop_count": 6,
  "unique_stop_count": 5
}
```
•	stop_count — количество остановок в кольцевой версии маршрута автобуса.

•	unique_stop_count — количество уникальных остановок, на которых останавливается автобус. Одинаковыми считаются остановки, имеющие одинаковые названия.

•	route_length — длина маршрута в метрах, вычисленная с использованием заданных выше расстояний по дорогам между остановками. Для простоты будем считать, что автобус проезжает путь между двумя соседними остановками по кратчайшему расстоянию по земной поверхности.

•	curvature (извилистость) — отношение длины маршрута, вычисленной с помощью дорожного расстояния, к длине маршрута, вычисленной с помощью географического расстояния. (При вычислении расстояния между двумя точками на земной поверхности считайте число π равным 3.1415926535, а радиус Земли — 6371 км.) Таким образом, curvature — вещественное число, большее единицы. Оно может быть равно единице только в том случае, если автобус едет между остановками по кратчайшему пути (и тогда больше похож на вертолёт), а меньше единицы может оказаться только благодаря телепортации или хордовым тоннелям.

Гарантируется, что для любых двух соседних остановок любого маршрута так или иначе задано расстояние по дорогам.

Если автобус не найден, выводится:
```json
{
  "request_id": /* id запроса */,
  "error_message": "not found"
}
```
#### Stop: информация об остановке
Пример:
```json
{
  "buses": [
    "256",
    "828"
  ],
  "request_id": 1042838872
}
```
buses — список автобусов (возможно, пустой), проходящих через эту остановку.
Если остановка не найдена, выводится
```json
{
  "request_id": /* id запроса */,
  "error_message": "not found"
}
```
#### Route: построение маршрута между двумя остановками

Помимо стандартных свойств id и type, запросы содержат ещё два:

•	from — остановка, в которой нужно начать маршрут.

•	to — остановка, в которой нужно закончить маршрут.

Оба значения — названия существующих в базе остановок.
Пример:
```json
{
  "type": "Route",
  "from": "Biryulyovo Zapadnoye",
  "to": "Universam",
  "id": 4
}
```
Данный запрос означает построение маршрута от остановки «Biryulyovo Zapadnoye» до остановки «Universam».

На маршруте человек может использовать несколько автобусов, и даже один автобус несколько раз — если на некоторых участках он делает большой крюк и проще срезать на другом автобусе.

Маршрут должен быть наиболее оптимален по времени. Если маршрутов с минимально возможным суммарным временем несколько, допускается вывести любой из них: тестирующая система проверяет лишь совпадение времени маршрута с оптимальным и корректность самого маршрута.

При прохождении маршрута время расходуется на два типа активностей:

•	Ожидание автобуса. Всегда длится bus_wait_time минут.

•	Поездка на автобусе. Всегда длится ровно такое количество времени, которое требуется для преодоления данного расстояния со скоростью bus_velocity. Расстояние между остановками вычисляется по дорогам, то есть с помощью road_distances.

Ходить пешком, выпрыгивать из автобуса между остановками и использовать другие виды транспорта запрещается. На конечных остановках все автобусы высаживают пассажиров и уезжают в парк. Даже если человек едет на кольцевом ("is_roundtrip": true) маршруте и хочет проехать мимо конечной, он будет вынужден выйти и подождать тот же самый автобус ровно bus_wait_time минут. Этот и другие случаи разобраны в примерах.

Ответ на запрос Route устроен следующим образом:
```json
{
    "request_id": <id запроса>,
    "total_time": <суммарное время>,
    "map": <svg документ маршрута>
    "items": [
        <элементы маршрута>
    ]
}
```
total_time — суммарное время в минутах, требуемое для прохождения маршрута, выведенное в виде вещественного числа.

items — список элементов маршрута, каждый из которых описывает непрерывную активность пассажира, требующую временных затрат. А именно, элементы маршрута бывают двух типов:
```
Wait — подождать нужное количество минут (в нашем случае — всегда bus_wait_time) на указанной остановке:
{
    "type": "Wait",
    "stop_name": "Biryulyovo",
    "time": 6
}
Bus — проехать span_count остановок (перегонов между остановками) на автобусе bus, потратив указанное количество минут:
{
    "type": "Bus",
    "bus": "297",
    "span_count": 2,
    "time": 5.235
}
```
map —  содержит SVG-документ в виде строки (аналогично запросу Map)

##### Отрисовка маршрута
Рисование карты с маршрутом состоит из следующих этапов:

1.	Выводим обычную карту целиком аналогично запросу Map, используя порядок слоёв, заданный настройкой layers.

2.	Выводим полупрозрачный прямоугольник, покрывающий всю карту.

3.	Выводим маршрут, используя порядок слоёв, заданный настройкой layers.

В случае отсутствия маршрута между указанными остановками выведите результат в следующем формате:
```json
{
    "request_id": <id запроса>,
    "error_message": "not found"
}
```
Map: построение карты автобусных маршрутов в формате SVG.
```json
"stat_requests": [
  /* ... */
  {
    "id": 999,
    "type": "Map"
  }
]
```
Ответ на запрос Map содержит единственный ключ "map" с SVG-документом:
```json
{
  "map": "<?xml version=\"1.0\" encoding=\"UTF-8\" ?><svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"></svg>"
}
```
Для этой программы была разработана простая библиотека для вывода векторных изображений в формате SVG, со следующими объектами:
```
•	Круг (Circle). Описывается координатами центра и радиусом.
•	Ломаная (Polyline). Описывается координатами вершин.
•	Надпись (Text). Описывается текстовым содержимым, координатами опорной точки, смещением относительно опорной точки, размером и названием шрифта.
•	Прямоугольник (Rectangle). Нужен, чтоб замылить базовую карту для построения самого маршрута.
Кроме того, все типы объектов имеют следующие свойства:
•	цвет линии и цвет заливки;
•	толщина линии;
•	тип формы конца линии и соединения линий.
```
Весь код библиотеки находится в пространстве имён Svg.

### Алгоритм отрисовки
Карта состоит из объектов трёх типов:
```
•	"bus_lines" — линии автобусов.
•	"bus_labels" — названия автобусов.
•	"stop_points" — круги остановок.
•	"stop_labels" — названия остановок.
```
Порядок отрисовки слоёв определяется исключительно настройкой layers. Более того, если какой-то из 4 слоёв отсутствует в списке, он не должен быть отрисован.
Проекция координат на карту

Одна из основных задач при рисовании карты — по координатам ключевых точек (в данном случае это автобусные остановки) на земной поверхности определить их координаты на карте (Svg::Point). Для кастомизации этого алгоритма используются три настройки отрисовки: width, height и padding.

Суть дальнейшего алгоритма — использование долгот и широт в качестве координат x и y и их масштабирование для вписания в прямоугольник (width - 2 * padding) × (height - 2 * padding).
Для начала, вычислим минимальные и максимальные значения широт и долгот: min_lat, min_lon, max_lat, max_lon. Дальнейшие преобразования приведут к тому, что остановка с минимальной долготой (longitude) будет иметь минимальную координату x — равную padding; остановка с максимальной широтой (самая северная) будет иметь минимальную координату y, тоже равную padding.
Вычислим максимально допустимый коэффициент масштабирования долгот в иксы: он равен width_zoom_coef = (width - 2 * padding) / (max_lon - min_lon). Аналогично, максимально допустимый коэффициент масштабирования широт в игреки height_zoom_coef = (height - 2 * padding) / (max_lat - min_lat).
Итоговый коэффициент масштабирования (единый для обеих осей) zoom_coef выберем как минимум из width_zoom_coef и height_zoom_coef. Если при вычислении одного из упомянутых выше коэффициентов возникло деление на 0 (из-за того, что все остановки имеют одинаковую широту или одинаковую долготу), в качестве zoom_coef необходимо выбрать другой из двух коэффициентов. Если же все остановки имеют одинаковые координаты, будем считать zoom_coef = 0.

Наконец, получаем следующие формулы вычисления x и y по долготе (lon) и широте (lat):
```
x = (lon - min_lon) * zoom_coef + padding;
y = (max_lat - lat) * zoom_coef + padding;
```
### Сжатие координат
Опишем используемый алгоритм сжатия координат на примере долгот (longitude) и иксов.
Рассмотрим долготы всех остановок в отсортированном порядке. Гарантируется, что долготы не повторяются, поэтому в удалении дублей нет необходимости. Цель — отобразить долготы на схеме таким образом, чтобы минимальная имела минимальный x (равный padding), максимальная долгота — максимальный x (равный width - padding), а остальные располагались равномерно между ними.

Пронумеруем долготы из полученного отсортированного массива без дублей: первая имеет номер 0, вторая — 1, последняя — lon_count - 1. Расстояние между иксами соседних долгот вычислим как x_step = (width - 2 * padding) / (lon_count - 1). Если долгота всего одна, ей, как и прежде, должен соответствовать минимальный x.
Теперь для произвольной долготы, имеющей номер idx, её x-координата на карте вычисляется как idx * x_step + padding.
Преобразования для широт аналогичны, с разницей лишь в итоговой формуле y-координаты: height - padding - idx * y_step.
Если соседние в отсортированном наборе долготы (или широты) не связаны напрямую отрезком автобусного маршрута, проходящего через соответствующие остановки, этим долготам (широтам) можно поставить в соответствие одинаковый номер и, как следствие, одинаковую x-координату (y-координату).

Первая (минимальная) долгота получает номер 0. Номер очередной долготы тоже равен 0, если среди предыдущих (то есть меньших её) долгот нет её маршрутных соседей (см. определение в части K). Если же у очередной долготы есть маршрутные соседи, меньшие её, то номер этой долготы равен номеру максимального из меньших её маршрутных соседей плюс один.
Пусть, например, все долготы представляют собой набор [50.1, 50.2, 50.3, 50.4]. Если они соответствуют остановкам разных автобусов, то получат номера [0, 0, 0, 0], как и раньше. Если же остановки [50.1, 50.2] соответствуют одному маршруту, а [50.3, 50.4] — другому, то долготы получат номера [0, 1, 0, 1], так как долгота 50.3 не имеет маршрутных соседей среди [50.1, 50.2].

Таким образом, сохраняется взаимный порядок остановок внутри одной линии, но между линиями он может нарушаться.

### Примеры карт:

![Alt-текст](https://github.com/BlindBlackHole/TravelTracker/blob/master/map1639812454.svg "map1639812454")

![Alt-текст](https://github.com/BlindBlackHole/TravelTracker/blob/master/map1821171961.svg "map1821171961")

### Примеры маршрутов:

![Alt-текст](https://github.com/BlindBlackHole/TravelTracker/blob/master/route133160474.svg "route133160474")

![Alt-текст](https://github.com/BlindBlackHole/TravelTracker/blob/master/route299735397.svg "route299735397")

![Alt-текст](https://github.com/BlindBlackHole/TravelTracker/blob/master/route822710686.svg "route822710686")
